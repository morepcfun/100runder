<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>100 Runder</title>
<link rel="icon" href="data:image/png;base64,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">

<style>
body {
margin: 0;
overflow: hidden;
background-color: #000000;
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
font-family: Arial, sans-serif;
color: #ecf0f1;
}
#gameContainer {
position: relative;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
}
canvas {
background-color: #333;
border: 0px solid #fff;
display: block;
cursor: default;
box-shadow: 2px 2px 4px 2px rgba(0, 0, 0, 0.75);
}
.game-controls {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 10;
background-color: rgba(0, 0, 0, 0.7);
padding: 15px 30px;
border-radius: 10px;
box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
color: white;
text-align: center;
display: flex;
flex-direction: column;
align-items: center;
gap: 10px;
}
.game-controls button,
#messageBox button {
background-color: #008cba;
color: white;
padding: 12px 25px;
border: none;
border-radius: 6px;
cursor: pointer;
font-size: 1.3em;
transition: background-color: 0.3s ease, transform 0.1s ease;
}
.game-controls button:hover,
#messageBox button:hover {
background-color: #007bb5;
transform: scale(1.02);
}
.game-controls button:active,
#messageBox button:active {
transform: scale(0.98);
}
#messageBox {
display: none;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: rgba(0, 0, 0, 0.85);
color: white;
padding: 25px 40px;
border-radius: 10px;
text-align: center;
z-index: 20;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
flex-direction: column;
align-items: center;
gap: 20px;
}
#messageBox p {
margin: 0;
font-size: 1.8em;
font-weight: bold;
}
#messageBox.win p {
color: #4CAF50;
}
#messageBox.lose p {
color: #F44336;
}
h2 {
position: absolute;
top: 50px;
color: white;
z-index: 10;
}
h1 {
font-size: 1.2rem;
color: Yellow;
margin-top: 2px;
margin-bottom: 10px;
text-shadow: 0 0 5px Black;
}
</style>
</head>
<body>
<div id="gameContainer">
<canvas id="racingCanvas"></canvas>
<div id="messageBox"></div>
<div class="game-controls">
<button id="startGameButton"></button>
<p id="controls-text"></p>
</div>
</div>
<script>
const lang = {
title: "100 Runder: Biljakt i Trafikken",
startGame: "Start Spillet",
playAgain: "Spill Igjen",
controls: "Bruk WASD eller piltastene",
lap: "Runde",
speed: "Fart",
life: "Liv",
policeCaught: "Du ble tatt av politiet!",
crashedTooMany: "Du krasjet for mange ganger!",
crashedWalls: "Du krasjet i veggen!",
win: "Du vant! Du klarte 100 runder!",
audioError: "Nettleseren stÃ¸tter ikke Web Audio API.",
};
class AudioManager {
constructor() {
this.audioCtx = null;
this.engineSound = null;
this.sirenSound = null;
}
init() {
if (!this.audioCtx) {
try {
this.audioCtx = new(window.AudioContext || window.webkitAudioContext)();
} catch (e) {
console.error(lang.audioError);
}
}
}
startEngine() {
if (!this.audioCtx || this.engineSound) return;
this.engineSound = this.audioCtx.createOscillator();
const gainNode = this.audioCtx.createGain();
this.engineSound.connect(gainNode);
gainNode.connect(this.audioCtx.destination);
this.engineSound.type = 'triangle';
this.engineSound.frequency.setValueAtTime(35, this.audioCtx.currentTime);
gainNode.gain.setValueAtTime(0.2, this.audioCtx.currentTime);
this.engineSound.start();
}
updateEngineSound(speed, maxSpeed) {
if (!this.engineSound) return;
const minPitch = 35;
const maxPitch = 70;
const pitch = minPitch + (speed / maxSpeed) * (maxPitch - minPitch);
this.engineSound.frequency.setTargetAtTime(pitch, this.audioCtx.currentTime, 0.05);
}
stopEngine() {
if (this.engineSound) {
this.engineSound.stop();
this.engineSound = null;
}
}
startSiren() {
if (!this.audioCtx || this.sirenSound) return;
const sirenNode = {
osc: this.audioCtx.createOscillator(),
gain: this.audioCtx.createGain(),
panner: this.audioCtx.createStereoPanner(),
interval: null,
};
sirenNode.osc.connect(sirenNode.gain);
sirenNode.gain.connect(sirenNode.panner);
sirenNode.panner.connect(this.audioCtx.destination);
sirenNode.osc.type = 'square';
sirenNode.gain.gain.setValueAtTime(0.04, this.audioCtx.currentTime);
sirenNode.osc.frequency.value = 1000;
sirenNode.osc.start();
let highTone = true;
sirenNode.interval = setInterval(() => {
const freq = highTone ? 700 : 1000;
sirenNode.osc.frequency.setTargetAtTime(freq, this.audioCtx.currentTime, 0.05);
sirenNode.panner.pan.setTargetAtTime(highTone ? -0.8 : 0.8, this.audioCtx.currentTime, 0.1);
highTone = !highTone;
}, 350);
this.sirenSound = sirenNode;
}
stopSiren() {
if (this.sirenSound) {
clearInterval(this.sirenSound.interval);
this.sirenSound.osc.stop();
this.sirenSound = null;
}
}
playCrashSound() {
if (!this.audioCtx) return;
const duration = 0.5;
const buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * duration, this.audioCtx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) {
data[i] = Math.random() * 2 - 1;
}
const noiseSource = this.audioCtx.createBufferSource();
noiseSource.buffer = buffer;
const gainNode = this.audioCtx.createGain();
gainNode.gain.setValueAtTime(0.4, this.audioCtx.currentTime);
gainNode.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + duration - 0.1);
noiseSource.connect(gainNode);
gainNode.connect(this.audioCtx.destination);
noiseSource.start();
}
}
const audioManager = new AudioManager();
const canvas = document.getElementById('racingCanvas');
const ctx = canvas.getContext('2d');
const startGameButton = document.getElementById('startGameButton');
const gameControlsDiv = document.querySelector('.game-controls');
const messageBox = document.getElementById('messageBox');
const BASE_WIDTH = 500;
const BASE_HEIGHT = 600;
let scale = 1;
const playerCarWidth = 20;
const playerCarHeight = 40;
const aiCarWidth = 20;
const aiCarHeight = 40;
const roadWidth = 400;
const laneWidth = roadWidth / 4;
const lapTarget = 100;
let gameRunning = false;
let animationFrameId;
let playerCarX;
let playerCarY;
const playerTurnSpeed = 240;
let playerLife = 100;
const collisionDamage = 5;
const wallHitCooldown = 500;
let lastWallHitTime = 0;
let playerCurrentSpeed = 50;
const accelerationRate = 120;
const decelerationRate = 150;
const maxSpeed = 300;
const minSpeed = 0;
const aiCars = [];
const numAICars = 10;
let policeCar = null;
const policeSpeedThreshold = 250;
let lightBlinkTimer = 0;
const lightBlinkInterval = 0.15;
let playerLap = 0;
let finishLineY = -100;
let finishLinePassed = false;
let lastTime = 0;
let deltaTime = 0;
let roadOffset = 0;
const particles = [];
const particleColors = ['#FF4500', '#FFA500', '#808080', '#696969'];
const keysPressed = {};
let policeCooldownActive = false;
document.addEventListener('keydown', (e) => {
const key = e.key.toLowerCase();
keysPressed[key] = true;
if (gameRunning && ['w', 'a', 's', 'd', 'arrowup', 'arrowleft', 'arrowdown', 'arrowright'].includes(key)) {
e.preventDefault();
}
});
document.addEventListener('keyup', (e) => {
keysPressed[e.key.toLowerCase()] = false;
});
function getLaneFromX(x) {
const roadLeftEdge = (BASE_WIDTH - roadWidth) / 2;
return Math.max(0, Math.min(3, Math.floor((x - roadLeftEdge) / laneWidth)));
}
function getLaneCenterX(laneIndex) {
const roadLeftEdge = (BASE_WIDTH - roadWidth) / 2;
return roadLeftEdge + laneIndex * laneWidth + (laneWidth / 2);
}
function drawRoundedRect(x, y, width, height, radius, color, strokeColor, strokeWidth) {
ctx.fillStyle = color;
ctx.beginPath();
ctx.moveTo(x + radius, y);
ctx.lineTo(x + width - radius, y);
ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
ctx.lineTo(x + width, y + height - radius);
ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
ctx.lineTo(x + radius, y + height);
ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
ctx.lineTo(x, y + radius);
ctx.quadraticCurveTo(x, y, x + radius, y);
ctx.closePath();
ctx.fill();
if (strokeColor) {
ctx.strokeStyle = strokeColor;
ctx.lineWidth = strokeWidth;
ctx.stroke();
}
}
function drawRect(x, y, width, height, color) {
ctx.fillStyle = color;
ctx.fillRect(x, y, width, height);
}
function drawCar(x, y, width, height, color) {
drawRect(x, y, width, height, color);
ctx.fillStyle = 'gray';
ctx.fillRect(x - 2, y + 5, 4, 10);
ctx.fillRect(x + width - 2, y + 5, 4, 10);
ctx.fillRect(x - 2, y + height - 15, 4, 10);
ctx.fillRect(x + width - 2, y + height - 15, 4, 10);
}
function drawCarWithLights(x, y, width, height, bodyColor, lightOn = false) {
drawRect(x, y, width, height, bodyColor);
ctx.fillStyle = 'gray';
ctx.fillRect(x - 2, y + 5, 4, 10);
ctx.fillRect(x + width - 2, y + 5, 4, 10);
ctx.fillRect(x - 2, y + height - 15, 4, 10);
ctx.fillRect(x + width - 2, y + height - 15, 4, 10);
if (lightOn) {
const lightSize = 5;
ctx.fillStyle = Math.floor(lightBlinkTimer / lightBlinkInterval) % 2 === 0 ? 'red' : 'darkred';
ctx.beginPath();
ctx.arc(x + width / 2 - 8, y + 5, lightSize, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = Math.floor(lightBlinkTimer / lightBlinkInterval) % 2 === 0 ? 'blue' : 'darkblue';
ctx.beginPath();
ctx.arc(x + width / 2 + 8, y + 5, lightSize, 0, Math.PI * 2);
ctx.fill();
}
}
function drawText(text, x, y, color, size = 20, align = 'center') {
ctx.fillStyle = color;
ctx.font = `${size}px Arial`;
ctx.textAlign = align;
ctx.fillText(text, x, y);
}
class Particle {
constructor(x, y, color, vx, vy, lifetime) {
this.x = x; this.y = y; this.vx = vx; this.vy = vy;
this.color = color; this.lifetime = lifetime; this.maxLifetime = lifetime;
this.radius = Math.random() * 2 + 1;
}
update() {
this.x += this.vx * deltaTime; this.y += this.vy * deltaTime;
this.lifetime -= 1; this.vx *= 0.95; this.vy *= 0.95;
}
draw() {
ctx.globalAlpha = this.lifetime / this.maxLifetime;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fillStyle = this.color; ctx.fill(); ctx.closePath();
ctx.globalAlpha = 1.0;
}
}
function createExplosion(x, y, numParticles = 10) {
for (let i = 0; i < numParticles; i++) {
const angle = Math.random() * Math.PI * 2;
const speed = Math.random() * 50 + 20;
const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed;
const color = particleColors[Math.floor(Math.random() * particleColors.length)];
const lifetime = Math.random() * 30 + 30;
particles.push(new Particle(x, y, color, vx, vy, lifetime));
}
}
function initializeGame() {
playerCarX = BASE_WIDTH / 2 - playerCarWidth / 2;
playerCarY = BASE_HEIGHT * 0.6;
playerLap = 0; playerLife = 100; lastWallHitTime = 0;
playerCurrentSpeed = minSpeed;
roadOffset = 0; finishLineY = -100; finishLinePassed = false;
aiCars.length = 0;
particles.length = 0;
policeCar = null; lightBlinkTimer = 0;
policeCooldownActive = false;
const aiColors = ['blue', 'green', 'purple', 'orange', 'cyan', 'magenta', 'red', 'lime', 'yellowgreen', 'darkviolet'];
for (let i = 0; i < numAICars; i++) {
const laneIndex = i % 4;
const x = getLaneCenterX(laneIndex) - aiCarWidth / 2;
aiCars.push({
x: x,
y: Math.random() * BASE_HEIGHT * 2 - BASE_HEIGHT * 3,
color: aiColors[i % aiColors.length],
speedMultiplier: 0.9 + Math.random() * 0.2,
lane: laneIndex
});
}
for (const key in keysPressed) {
if (keysPressed.hasOwnProperty(key)) { keysPressed[key] = false; }
}
}
function updatePoliceCar() {
if (!gameRunning || !policeCar) return;
const policeLane = getLaneFromX(policeCar.x);
const playerLane = getLaneFromX(playerCarX);
const visionDistance = 150;
let obstacleInLane = false;
for (const car of aiCars) {
if (getLaneFromX(car.x) === policeLane && car.y < policeCar.y && car.y > policeCar.y - visionDistance) {
obstacleInLane = true;
break;
}
}
let targetLane = policeLane;
if (obstacleInLane) {
const rightLane = policeLane + 1;
const leftLane = policeLane - 1;
let rightLaneClear = rightLane <= 3;
let leftLaneClear = leftLane >= 0;
for (const car of aiCars) {
const carLane = getLaneFromX(car.x);
if (car.y < policeCar.y && car.y > policeCar.y - visionDistance) {
if (carLane === rightLane) rightLaneClear = false;
if (carLane === leftLane) leftLaneClear = false;
}
}
if (rightLaneClear) targetLane = rightLane;
else if (leftLaneClear) targetLane = leftLane;
} else if (policeLane !== playerLane) {
targetLane = playerLane;
}
policeCar.targetX = getLaneCenterX(targetLane) - policeCar.width / 2;
const horizontalSpeed = 150;
if (policeCar.x < policeCar.targetX) {
policeCar.x = Math.min(policeCar.x + horizontalSpeed * deltaTime, policeCar.targetX);
} else if (policeCar.x > policeCar.targetX) {
policeCar.x = Math.max(policeCar.x - horizontalSpeed * deltaTime, policeCar.targetX);
}
const distanceToPlayer = policeCar.y - playerCarY;
const followDistance = 80;
let policeCurrentSpeed;
if (policeCar.mode === 'approaching' && distanceToPlayer <= followDistance) {
policeCar.mode = 'following';
}
if (policeCar.mode === 'approaching') {
policeCurrentSpeed = maxSpeed * 1.2;
} else {
policeCurrentSpeed = 280;
if (obstacleInLane) policeCurrentSpeed *= 0.9;
}
const relativeSpeed = policeCurrentSpeed - playerCurrentSpeed;
policeCar.y -= relativeSpeed * deltaTime;
lightBlinkTimer += deltaTime;
if (policeCar.y < -policeCar.height * 2 || policeCar.y > BASE_HEIGHT + policeCar.height) {
audioManager.stopSiren();
policeCar = null;
policeCooldownActive = true;
return;
}
const policeHitbox = { left: policeCar.x, right: policeCar.x + playerCarWidth, top: policeCar.y, bottom: policeCar.y + playerCarHeight };
const playerHitbox = { left: playerCarX, right: playerCarX + playerCarWidth, top: playerCarY, bottom: playerCarY + playerCarHeight };
if (playerHitbox.left < policeHitbox.right && playerHitbox.right > policeHitbox.left && playerHitbox.top < policeHitbox.bottom && playerHitbox.bottom > policeHitbox.top) {
stopGame(lang.policeCaught);
}
}
function movePlayerCar() {
if (!gameRunning) return;
if (keysPressed['a'] || keysPressed['arrowleft']) {
playerCarX -= playerTurnSpeed * deltaTime;
}
if (keysPressed['d'] || keysPressed['arrowright']) {
playerCarX += playerTurnSpeed * deltaTime;
}
if (keysPressed['w'] || keysPressed['arrowup']) {
playerCurrentSpeed += accelerationRate * deltaTime;
} else if (keysPressed['s'] || keysPressed['arrowdown']) {
playerCurrentSpeed -= decelerationRate * deltaTime;
}
playerCurrentSpeed = Math.max(minSpeed, Math.min(playerCurrentSpeed, maxSpeed));
if (playerCurrentSpeed < policeSpeedThreshold) {
policeCooldownActive = false;
}
if (playerCurrentSpeed > policeSpeedThreshold && policeCar === null && gameRunning && !policeCooldownActive) {
const lane = Math.floor(Math.random() * 4);
policeCar = {
x: getLaneCenterX(lane) - playerCarWidth / 2,
y: BASE_HEIGHT,
width: playerCarWidth, height: playerCarHeight, targetX: playerCarX,
mode: 'approaching'
};
audioManager.startSiren();
}
}
function moveAICars() {
if (!gameRunning) return;
for (const car of aiCars) {
car.y += car.speedMultiplier * playerCurrentSpeed * deltaTime;
if (Math.random() < 0.01) {
car.lane = Math.floor(Math.random() * 4);
}
const targetX = getLaneCenterX(car.lane) - aiCarWidth / 2;
const horizontalSpeed = 50;
if (car.x < targetX) {
car.x = Math.min(car.x + horizontalSpeed * deltaTime, targetX);
} else if (car.x > targetX) {
car.x = Math.max(car.x - horizontalSpeed * deltaTime, targetX);
}
if (car.y > BASE_HEIGHT) {
car.y = -aiCarHeight - Math.random() * BASE_HEIGHT * 0.5;
const newLane = Math.floor(Math.random() * 4);
car.lane = newLane;
car.x = getLaneCenterX(newLane) - aiCarWidth / 2;
}
}
}
function updateCarCollisions() {
const allCars = [...aiCars];
if (policeCar) {
allCars.push(policeCar);
}
for (let i = 0; i < allCars.length; i++) {
for (let j = i + 1; j < allCars.length; j++) {
const carA = allCars[i];
const carB = allCars[j];
if (carA.x < carB.x + aiCarWidth && carA.x + aiCarWidth > carB.x &&
carA.y < carB.y + aiCarHeight && carA.y + aiCarHeight > carB.y) {
const dx = (carA.x + aiCarWidth / 2) - (carB.x + aiCarWidth / 2);
const dy = (carA.y + aiCarHeight / 2) - (carB.y + aiCarHeight / 2);
const overlapX = (aiCarWidth + 4) - Math.abs(dx);
const overlapY = (aiCarHeight) - Math.abs(dy);
if (overlapX < overlapY) {
if (dx > 0) {
carA.x += overlapX / 2;
carB.x -= overlapX / 2;
} else {
carA.x -= overlapX / 2;
carB.x += overlapX / 2;
}
} else {
if (dy > 0) {
carA.y += overlapY / 2;
carB.y -= overlapY / 2;
} else {
carA.y -= overlapY / 2;
carB.y += overlapY / 2;
}
}
if ((carA === policeCar || carB === policeCar) && policeCar.mode === 'following') {
policeCar.y += 5;
}
}
}
}
}
function checkCollisions() {
if (!gameRunning) return;
for (const aiCar of aiCars) {
if (playerCarX < aiCar.x + aiCarWidth && playerCarX + playerCarWidth > aiCar.x && playerCarY < aiCar.y + aiCarHeight && playerCarY + playerCarHeight > aiCar.y) {
playerLife -= collisionDamage;
createExplosion(playerCarX + playerCarWidth / 2, playerCarY + playerCarHeight / 2);
playerCurrentSpeed *= 0.9;
audioManager.playCrashSound();
if (playerLife <= 0) { stopGame(lang.crashedTooMany); return; }
if (playerCarX < aiCar.x) { aiCar.x += 10; }
else { aiCar.x -= 10; }
}
}
}
function checkWallCollisions() {
if (!gameRunning) return;
const roadLeftEdge = (BASE_WIDTH - roadWidth) / 2;
const roadRightEdge = (BASE_WIDTH + roadWidth) / 2;
const currentTime = performance.now();
if (playerCarX < roadLeftEdge || playerCarX + playerCarWidth > roadRightEdge) {
if (currentTime - lastWallHitTime > wallHitCooldown) {
playerLife -= collisionDamage;
lastWallHitTime = currentTime;
playerCurrentSpeed *= 0.9;
audioManager.playCrashSound();
if (playerCarX < roadLeftEdge) {
createExplosion(roadLeftEdge, playerCarY + playerCarHeight / 2);
} else {
createExplosion(roadRightEdge, playerCarY + playerCarHeight / 2);
}
if (playerLife <= 0) { stopGame(lang.crashedWalls); return; }
}
playerCarX = Math.max(roadLeftEdge, Math.min(playerCarX, roadRightEdge - playerCarWidth));
}
}
function checkLaps() {
if (!gameRunning) return;
const prevFinishLineY = finishLineY;
finishLineY += playerCurrentSpeed * deltaTime;
if (
prevFinishLineY < playerCarY + playerCarHeight &&
finishLineY >= playerCarY + playerCarHeight
) {
if (!finishLinePassed) {
playerLap++;
finishLinePassed = true;
}
} else if (finishLineY >= BASE_HEIGHT + 100) {
finishLineY = -100 - Math.random() * 200;
finishLinePassed = false;
}
if (playerLap >= lapTarget) {
stopGame(lang.win);
return;
}
}
function drawEverything() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.save();
ctx.scale(scale, scale);
drawRect(0, 0, BASE_WIDTH, BASE_HEIGHT, 'darkgray');
const roadX = (BASE_WIDTH - roadWidth) / 2;
drawRect(roadX, 0, roadWidth, BASE_HEIGHT, '#333');
roadOffset = (roadOffset + playerCurrentSpeed * deltaTime) % 100;
ctx.strokeStyle = 'white';
ctx.lineWidth = 5;
const numLines = Math.ceil(BASE_HEIGHT / 50);
for (let i = 0; i < numLines; i++) {
const lineY = (i * 100 + roadOffset) % (BASE_HEIGHT + 100) - 100;
ctx.beginPath();
ctx.setLineDash([30, 20]);
ctx.moveTo(BASE_WIDTH / 2, lineY);
ctx.lineTo(BASE_WIDTH / 2, lineY + 50);
ctx.stroke();
ctx.setLineDash([10, 30]);
for (let j = 1; j < 4; j++) {
const laneDividerX = roadX + j * laneWidth;
ctx.beginPath();
ctx.moveTo(laneDividerX, lineY);
ctx.lineTo(laneDividerX, lineY + 50);
ctx.stroke();
}
}
ctx.setLineDash([]);
ctx.strokeStyle = 'red';
ctx.lineWidth = 10;
ctx.beginPath();
ctx.moveTo(roadX, finishLineY);
ctx.lineTo(roadX + roadWidth, finishLineY);
ctx.stroke();
drawCar(playerCarX, playerCarY, playerCarWidth, playerCarHeight, 'yellow');
for (const aiCar of aiCars) {
drawCar(aiCar.x, aiCar.y, aiCarWidth, aiCarHeight, aiCar.color);
}
if (policeCar) {
drawCarWithLights(policeCar.x, policeCar.y, policeCar.width, policeCar.height, "#3366CC", true);
}
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
p.update(); p.draw();
if (p.lifetime <= 0) { particles.splice(i, 1); }
}
const lapBoxWidth = 160; const lapBoxHeight = 35;
const lapBoxX = BASE_WIDTH / 2 - lapBoxWidth / 2; const lapBoxY = 10;
const radius = 8;
drawRoundedRect(lapBoxX, lapBoxY, lapBoxWidth, lapBoxHeight, radius, 'rgba(0, 0, 0, 0.6)', 'white', 1);
drawText(`${lang.lap} ${playerLap}/${lapTarget}`, BASE_WIDTH / 2, lapBoxY + 24, 'white', 20);
const lifeBarWidth = 156; const lifeBarHeight = 15;
const lifeBarX = BASE_WIDTH / 2 - lifeBarWidth / 2; const lifeBarY = 60;
drawRect(lifeBarX, lifeBarY, lifeBarWidth, lifeBarHeight, 'gray');
drawRect(lifeBarX, lifeBarY, lifeBarWidth * (playerLife / 100), lifeBarHeight, playerLife > 50 ? 'lime' : playerLife > 20 ? 'orange' : 'red');
ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
ctx.strokeRect(lifeBarX, lifeBarY, lifeBarWidth, lifeBarHeight);
drawText(`${lang.life} ${playerLife}%`, lifeBarX + lifeBarWidth / 2, lifeBarY + lifeBarHeight / 2 + 5, 'black', 12);
drawText(`${lang.speed}: ${Math.round(playerCurrentSpeed)}`, BASE_WIDTH / 2, 95, 'white', 16);
ctx.restore();
}
function resizeCanvas() {
const displayWidth = window.innerWidth;
const displayHeight = window.innerHeight;
const widthRatio = displayWidth / BASE_WIDTH;
const heightRatio = displayHeight / BASE_HEIGHT;
scale = Math.min(widthRatio, heightRatio);
canvas.width = BASE_WIDTH * scale;
canvas.height = BASE_HEIGHT * scale;
}
function gameLoop(currentTime) {
if (!gameRunning) { lastTime = currentTime; return; }
deltaTime = Math.min(0.05, (currentTime - lastTime) / 1000);
lastTime = currentTime;
audioManager.updateEngineSound(playerCurrentSpeed, maxSpeed);
movePlayerCar();
moveAICars();
updatePoliceCar();
updateCarCollisions();
checkCollisions();
checkWallCollisions();
checkLaps();
drawEverything();
animationFrameId = requestAnimationFrame(gameLoop);
}
function startGame() {
if (!gameRunning) {
audioManager.init();
audioManager.startEngine();
gameRunning = true;
gameControlsDiv.style.display = 'none';
messageBox.style.display = 'none';
initializeGame();
lastTime = performance.now();
drawEverything();
requestAnimationFrame(gameLoop);
}
}
function stopGame(message) {
if (gameRunning) {
gameRunning = false;
cancelAnimationFrame(animationFrameId);
audioManager.stopEngine();
audioManager.stopSiren();
gameControlsDiv.style.display = 'none';
const isWin = message.toLowerCase().includes('won') || message.toLowerCase().includes('vant');
messageBox.innerHTML = `
<p>${message}</p>
<button id="restartButton">${lang.playAgain}</button>
`;
messageBox.className = isWin ? 'win' : 'lose';
messageBox.style.display = 'flex';
document.getElementById('restartButton').addEventListener('click', startGame);
}
}
function updateStaticUIText(){
document.title = lang.title;
startGameButton.textContent = lang.startGame;
document.getElementById('controls-text').textContent = lang.controls;
}
updateStaticUIText();
startGameButton.addEventListener('click', startGame);
window.addEventListener('resize', () => {
resizeCanvas();
if (!gameRunning) {
drawEverything();
}
});
resizeCanvas();
initializeGame();
drawEverything();
</script>
</body>
</html>
