<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100 Laps</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            color: #ecf0f1;
        }

        #gameContainer {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        canvas {
            background-color: #333;
            border: 0px solid #fff;
            display: block;
            cursor: default;
            box-shadow: 2px 2px 4px 2px rgba(0, 0, 0, 0.75);
        }

        .game-controls {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .game-controls button,
        #messageBox button {
            background-color: #008cba;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.3em;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        .game-controls button:hover,
        #messageBox button:hover {
            background-color: #007bb5;
            transform: scale(1.02);
        }

        .game-controls button:active,
        #messageBox button:active {
            transform: scale(0.98);
        }

        #messageBox {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 25px 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #messageBox p {
            margin: 0;
            font-size: 1.8em;
            font-weight: bold;
        }

        #messageBox.win p {
            color: #4CAF50;
        }

        #messageBox.lose p {
            color: #F44336;
        }

        h2 {
            position: absolute;
            top: 50px;
            color: white;
            z-index: 10;
        }

        h1 {
            font-size: 1.2rem;
            color: Yellow;
            margin-top: 2px;
            margin-bottom: 10px;
            text-shadow: 0 0 5px Black;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="racingCanvas"></canvas>
        <div id="messageBox"></div>
        <div class="game-controls">
            <button id="startGameButton"></button>
            <p id="controls-text"></p>
        </div>
    </div>

    <script>
        // --- TEXT & LANGUAGE SETTINGS ---
        const lang = {
            title: "100 Laps: Traffic Car Chase",
            startGame: "Start Game",
            playAgain: "Play Again",
            controls: "Use WASD or Arrow Keys",
            lap: "Lap",
            speed: "Speed",
            life: "Life",
            policeCaught: "You were caught by the police!",
            crashedTooMany: "You crashed too many times!",
            crashedWalls: "You crashed into the wall!",
            win: "You won! You completed 100 laps!",
            audioError: "Browser does not support the Web Audio API.",
        };

        // --- AUDIO MANAGER ---
        class AudioManager {
            constructor() {
                this.audioCtx = null;
                this.engineSound = null;
                this.sirenSound = null;
            }

            init() {
                if (!this.audioCtx) {
                    try {
                        this.audioCtx = new(window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.error(lang.audioError);
                    }
                }
            }

            startEngine() {
                if (!this.audioCtx || this.engineSound) return;
                this.engineSound = this.audioCtx.createOscillator();
                const gainNode = this.audioCtx.createGain();
                this.engineSound.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);
                this.engineSound.type = 'triangle';
                this.engineSound.frequency.setValueAtTime(35, this.audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.2, this.audioCtx.currentTime);
                this.engineSound.start();
            }

            updateEngineSound(speed, maxSpeed) {
                if (!this.engineSound) return;
                const minPitch = 35;
                const maxPitch = 70;
                const pitch = minPitch + (speed / maxSpeed) * (maxPitch - minPitch);
                this.engineSound.frequency.setTargetAtTime(pitch, this.audioCtx.currentTime, 0.05);
            }

            stopEngine() {
                if (this.engineSound) {
                    this.engineSound.stop();
                    this.engineSound = null;
                }
            }

            startSiren() {
                if (!this.audioCtx || this.sirenSound) return;
                const sirenNode = {
                    osc: this.audioCtx.createOscillator(),
                    gain: this.audioCtx.createGain(),
                    panner: this.audioCtx.createStereoPanner(),
                    interval: null,
                };
                sirenNode.osc.connect(sirenNode.gain);
                sirenNode.gain.connect(sirenNode.panner);
                sirenNode.panner.connect(this.audioCtx.destination);
                sirenNode.osc.type = 'square';
                sirenNode.gain.gain.setValueAtTime(0.04, this.audioCtx.currentTime);
                sirenNode.osc.frequency.value = 1000;
                sirenNode.osc.start();

                let highTone = true;
                sirenNode.interval = setInterval(() => {
                    const freq = highTone ? 700 : 1000;
                    sirenNode.osc.frequency.setTargetAtTime(freq, this.audioCtx.currentTime, 0.05);
                    sirenNode.panner.pan.setTargetAtTime(highTone ? -0.8 : 0.8, this.audioCtx.currentTime, 0.1);
                    highTone = !highTone;
                }, 350);
                this.sirenSound = sirenNode;
            }

            stopSiren() {
                if (this.sirenSound) {
                    clearInterval(this.sirenSound.interval);
                    this.sirenSound.osc.stop();
                    this.sirenSound = null;
                }
            }

            playCrashSound() {
                if (!this.audioCtx) return;
                const duration = 0.5;
                const buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * duration, this.audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noiseSource = this.audioCtx.createBufferSource();
                noiseSource.buffer = buffer;
                const gainNode = this.audioCtx.createGain();
                gainNode.gain.setValueAtTime(0.4, this.audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + duration - 0.1);
                noiseSource.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);
                noiseSource.start();
            }
        }
        const audioManager = new AudioManager();

        // --- DOM & CANVAS ELEMENTS ---
        const canvas = document.getElementById('racingCanvas');
        const ctx = canvas.getContext('2d');
        const startGameButton = document.getElementById('startGameButton');
        const gameControlsDiv = document.querySelector('.game-controls');
        const messageBox = document.getElementById('messageBox');

        // --- GAME CONSTANTS & SETTINGS ---
        const BASE_WIDTH = 500;
        const BASE_HEIGHT = 600;
        const playerCarWidth = 20;
        const playerCarHeight = 40;
        const aiCarWidth = 20;
        const aiCarHeight = 40;
        const roadWidth = 400;
        const laneWidth = roadWidth / 4;
        const lapTarget = 100;
        const numAICars = 10;
        const policeSpeedThreshold = 250;
        const particleColors = ['#FF4500', '#FFA500', '#808080', '#696969'];

        // --- PLAYER SETTINGS ---
        const playerTurnSpeed = 240;
        const accelerationRate = 120;
        const decelerationRate = 150;
        const maxSpeed = 300;
        const minSpeed = 0;
        const collisionDamage = 5;
        const wallHitCooldown = 500; // in ms

        // --- GAME STATE VARIABLES ---
        let scale = 1;
        let gameRunning = false;
        let animationFrameId;
        let playerCarX, playerCarY;
        let playerLife;
        let lastWallHitTime;
        let playerCurrentSpeed;
        let playerLap;
        let finishLineY;
        let finishLinePassed;
        let lastTime = 0;
        let deltaTime = 0;
        let roadOffset = 0;
        let lightBlinkTimer = 0;
        const lightBlinkInterval = 0.15;
        const aiCars = [];
        let policeCar = null;
        let policeCooldownActive = false;
        const particles = [];
        const keysPressed = {};

        // --- EVENT LISTENERS ---
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keysPressed[key] = true;
            if (gameRunning && ['w', 'a', 's', 'd', 'arrowup', 'arrowleft', 'arrowdown', 'arrowright'].includes(key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key.toLowerCase()] = false;
        });

        // --- UTILITY FUNCTIONS ---
        function getLaneFromX(x) {
            const roadLeftEdge = (BASE_WIDTH - roadWidth) / 2;
            return Math.max(0, Math.min(3, Math.floor((x - roadLeftEdge) / laneWidth)));
        }

        function getLaneCenterX(laneIndex) {
            const roadLeftEdge = (BASE_WIDTH - roadWidth) / 2;
            return roadLeftEdge + laneIndex * laneWidth + (laneWidth / 2);
        }

        // --- DRAWING FUNCTIONS ---
        function drawRoundedRect(x, y, width, height, radius, color, strokeColor, strokeWidth) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();

            if (strokeColor) {
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();
            }
        }

        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
        }

        function drawCar(x, y, width, height, color) {
            drawRect(x, y, width, height, color);
            // Draw wheels
            ctx.fillStyle = 'gray';
            ctx.fillRect(x - 2, y + 5, 4, 10);
            ctx.fillRect(x + width - 2, y + 5, 4, 10);
            ctx.fillRect(x - 2, y + height - 15, 4, 10);
            ctx.fillRect(x + width - 2, y + height - 15, 4, 10);
        }

        function drawCarWithLights(x, y, width, height, bodyColor, lightOn = false) {
            drawCar(x, y, width, height, bodyColor);
            if (lightOn) {
                const lightSize = 5;
                const isRedOn = Math.floor(lightBlinkTimer / lightBlinkInterval) % 2 === 0;
                // Red light
                ctx.fillStyle = isRedOn ? 'red' : 'darkred';
                ctx.beginPath();
                ctx.arc(x + width / 2 - 8, y + 5, lightSize, 0, Math.PI * 2);
                ctx.fill();
                // Blue light
                ctx.fillStyle = isRedOn ? 'darkblue' : 'blue';
                ctx.beginPath();
                ctx.arc(x + width / 2 + 8, y + 5, lightSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawText(text, x, y, color, size = 20, align = 'center') {
            ctx.fillStyle = color;
            ctx.font = `${size}px Arial`;
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y, color, vx, vy, lifetime) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.lifetime = lifetime;
                this.maxLifetime = lifetime;
                this.radius = Math.random() * 2 + 1;
            }

            update() {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.lifetime -= 1;
                this.vx *= 0.95;
                this.vy *= 0.95;
            }

            draw() {
                ctx.globalAlpha = this.lifetime / this.maxLifetime;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
                ctx.globalAlpha = 1.0;
            }
        }

        function createExplosion(x, y, numParticles = 10) {
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 50 + 20;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                const lifetime = Math.random() * 30 + 30;
                particles.push(new Particle(x, y, color, vx, vy, lifetime));
            }
        }

        // --- GAME LOGIC ---
        function initializeGame() {
            playerCarX = BASE_WIDTH / 2 - playerCarWidth / 2;
            playerCarY = BASE_HEIGHT * 0.6;
            playerLap = 0;
            playerLife = 100;
            lastWallHitTime = 0;
            playerCurrentSpeed = minSpeed;
            roadOffset = 0;
            finishLineY = -100;
            finishLinePassed = false;
            aiCars.length = 0;
            particles.length = 0;
            policeCar = null;
            lightBlinkTimer = 0;
            policeCooldownActive = false;

            const aiColors = ['#0077b6', '#00b4d8', '#90e0ef', '#6a0dad', '#e0aaff', '#e63946', '#f1faee', '#a8dadc', '#457b9d', '#1d3557'];
            for (let i = 0; i < numAICars; i++) {
                const laneIndex = i % 4;
                const x = getLaneCenterX(laneIndex) - aiCarWidth / 2;
                aiCars.push({
                    x: x,
                    y: Math.random() * BASE_HEIGHT * 2 - BASE_HEIGHT * 3,
                    color: aiColors[i % aiColors.length],
                    speedMultiplier: 0.9 + Math.random() * 0.2,
                    lane: laneIndex
                });
            }

            // Reset keyboard state
            for (const key in keysPressed) {
                if (keysPressed.hasOwnProperty(key)) {
                    keysPressed[key] = false;
                }
            }
        }

        function updatePoliceCar() {
            if (!gameRunning || !policeCar) return;

            const policeLane = getLaneFromX(policeCar.x);
            const playerLane = getLaneFromX(playerCarX);
            const visionDistance = 150;
            let obstacleInLane = false;

            // Check for obstacles in the police car's current lane
            for (const car of aiCars) {
                if (getLaneFromX(car.x) === policeLane && car.y < policeCar.y && car.y > policeCar.y - visionDistance) {
                    obstacleInLane = true;
                    break;
                }
            }

            // --- AI Lane Changing Logic ---
            let targetLane = policeLane;
            if (obstacleInLane) {
                // If blocked, try to switch to a clear adjacent lane
                const rightLane = policeLane + 1;
                const leftLane = policeLane - 1;
                let rightLaneClear = rightLane <= 3;
                let leftLaneClear = leftLane >= 0;

                for (const car of aiCars) {
                    const carLane = getLaneFromX(car.x);
                    if (car.y < policeCar.y && car.y > policeCar.y - visionDistance) {
                        if (carLane === rightLane) rightLaneClear = false;
                        if (carLane === leftLane) leftLaneClear = false;
                    }
                }

                if (rightLaneClear) targetLane = rightLane;
                else if (leftLaneClear) targetLane = leftLane;
            } else if (policeLane !== playerLane) {
                // If not blocked, try to move into the player's lane
                targetLane = playerLane;
            }

            policeCar.targetX = getLaneCenterX(targetLane) - policeCar.width / 2;
            const horizontalSpeed = 150;
            if (policeCar.x < policeCar.targetX) {
                policeCar.x = Math.min(policeCar.x + horizontalSpeed * deltaTime, policeCar.targetX);
            } else if (policeCar.x > policeCar.targetX) {
                policeCar.x = Math.max(policeCar.x - horizontalSpeed * deltaTime, policeCar.targetX);
            }

            // --- AI Speed and Following Logic ---
            const distanceToPlayer = policeCar.y - playerCarY;
            const followDistance = 80;
            let policeCurrentSpeed;

            if (policeCar.mode === 'approaching' && distanceToPlayer <= followDistance) {
                policeCar.mode = 'following';
            }

            if (policeCar.mode === 'approaching') {
                policeCurrentSpeed = maxSpeed * 1.2;
            } else { // 'following' mode
                policeCurrentSpeed = 280;
                if (obstacleInLane) policeCurrentSpeed *= 0.9;
            }

            const relativeSpeed = policeCurrentSpeed - playerCurrentSpeed;
            policeCar.y -= relativeSpeed * deltaTime;
            lightBlinkTimer += deltaTime;

            // Despawn if off-screen
            if (policeCar.y < -policeCar.height * 2 || policeCar.y > BASE_HEIGHT + policeCar.height) {
                audioManager.stopSiren();
                policeCar = null;
                policeCooldownActive = true;
                return;
            }

            // Check collision with player
            const policeHitbox = { left: policeCar.x, right: policeCar.x + playerCarWidth, top: policeCar.y, bottom: policeCar.y + playerCarHeight };
            const playerHitbox = { left: playerCarX, right: playerCarX + playerCarWidth, top: playerCarY, bottom: playerCarY + playerCarHeight };
            if (playerHitbox.left < policeHitbox.right && playerHitbox.right > policeHitbox.left && playerHitbox.top < policeHitbox.bottom && playerHitbox.bottom > policeHitbox.top) {
                stopGame(lang.policeCaught);
            }
        }

        function movePlayerCar() {
            if (!gameRunning) return;

            if (keysPressed['a'] || keysPressed['arrowleft']) {
                playerCarX -= playerTurnSpeed * deltaTime;
            }
            if (keysPressed['d'] || keysPressed['arrowright']) {
                playerCarX += playerTurnSpeed * deltaTime;
            }
            if (keysPressed['w'] || keysPressed['arrowup']) {
                playerCurrentSpeed += accelerationRate * deltaTime;
            } else if (keysPressed['s'] || keysPressed['arrowdown']) {
                playerCurrentSpeed -= decelerationRate * deltaTime;
            }

            playerCurrentSpeed = Math.max(minSpeed, Math.min(playerCurrentSpeed, maxSpeed));

            // Logic for spawning the police car
            if (playerCurrentSpeed < policeSpeedThreshold) {
                policeCooldownActive = false;
            }

            if (playerCurrentSpeed > policeSpeedThreshold && policeCar === null && gameRunning && !policeCooldownActive) {
                const lane = Math.floor(Math.random() * 4);
                policeCar = {
                    x: getLaneCenterX(lane) - playerCarWidth / 2,
                    y: BASE_HEIGHT,
                    width: playerCarWidth,
                    height: playerCarHeight,
                    targetX: playerCarX,
                    mode: 'approaching'
                };
                audioManager.startSiren();
            }
        }

        function moveAICars() {
            if (!gameRunning) return;
            for (const car of aiCars) {
                car.y += car.speedMultiplier * playerCurrentSpeed * deltaTime;

                // Simple random lane change logic
                if (Math.random() < 0.01) {
                    car.lane = Math.floor(Math.random() * 4);
                }

                const targetX = getLaneCenterX(car.lane) - aiCarWidth / 2;
                const horizontalSpeed = 50;
                if (car.x < targetX) {
                    car.x = Math.min(car.x + horizontalSpeed * deltaTime, targetX);
                } else if (car.x > targetX) {
                    car.x = Math.max(car.x - horizontalSpeed * deltaTime, targetX);
                }

                // Respawn car when it goes off screen
                if (car.y > BASE_HEIGHT) {
                    car.y = -aiCarHeight - Math.random() * BASE_HEIGHT * 0.5;
                    const newLane = Math.floor(Math.random() * 4);
                    car.lane = newLane;
                    car.x = getLaneCenterX(newLane) - aiCarWidth / 2;
                }
            }
        }

        function updateCarCollisions() {
            const allCars = [...aiCars];
            if (policeCar) {
                allCars.push(policeCar);
            }

            for (let i = 0; i < allCars.length; i++) {
                for (let j = i + 1; j < allCars.length; j++) {
                    const carA = allCars[i];
                    const carB = allCars[j];

                    if (carA.x < carB.x + aiCarWidth && carA.x + aiCarWidth > carB.x &&
                        carA.y < carB.y + aiCarHeight && carA.y + aiCarHeight > carB.y) {
                        
                        // Basic collision resolution: push cars apart
                        const dx = (carA.x + aiCarWidth / 2) - (carB.x + aiCarWidth / 2);
                        const dy = (carA.y + aiCarHeight / 2) - (carB.y + aiCarHeight / 2);
                        const overlapX = (aiCarWidth + 4) - Math.abs(dx);
                        const overlapY = (aiCarHeight) - Math.abs(dy);

                        if (overlapX < overlapY) {
                            if (dx > 0) {
                                carA.x += overlapX / 2;
                                carB.x -= overlapX / 2;
                            } else {
                                carA.x -= overlapX / 2;
                                carB.x += overlapX / 2;
                            }
                        } else {
                            if (dy > 0) {
                                carA.y += overlapY / 2;
                                carB.y -= overlapY / 2;
                            } else {
                                carA.y -= overlapY / 2;
                                carB.y += overlapY / 2;
                            }
                        }
                        // Prevent police car from being stuck
                        if ((carA === policeCar || carB === policeCar) && policeCar.mode === 'following') {
                           policeCar.y += 5; 
                        }
                    }
                }
            }
        }

        function checkPlayerCollisions() {
            if (!gameRunning) return;
            // Player vs AI Cars
            for (const aiCar of aiCars) {
                if (playerCarX < aiCar.x + aiCarWidth && playerCarX + playerCarWidth > aiCar.x && playerCarY < aiCar.y + aiCarHeight && playerCarY + playerCarHeight > aiCar.y) {
                    playerLife -= collisionDamage;
                    createExplosion(playerCarX + playerCarWidth / 2, playerCarY + playerCarHeight / 2);
                    playerCurrentSpeed *= 0.9;
                    audioManager.playCrashSound();
                    if (playerLife <= 0) {
                        stopGame(lang.crashedTooMany);
                        return;
                    }
                    // Push AI car away on collision
                    if (playerCarX < aiCar.x) { aiCar.x += 10; } 
                    else { aiCar.x -= 10; }
                }
            }
        }
        
        function checkWallCollisions() {
             if (!gameRunning) return;
            const roadLeftEdge = (BASE_WIDTH - roadWidth) / 2;
            const roadRightEdge = (BASE_WIDTH + roadWidth) / 2;
            const currentTime = performance.now();

            if (playerCarX < roadLeftEdge || playerCarX + playerCarWidth > roadRightEdge) {
                if (currentTime - lastWallHitTime > wallHitCooldown) {
                    playerLife -= collisionDamage;
                    lastWallHitTime = currentTime;
                    playerCurrentSpeed *= 0.9;
                    audioManager.playCrashSound();
                    
                    if (playerCarX < roadLeftEdge) {
                        createExplosion(roadLeftEdge, playerCarY + playerCarHeight / 2);
                    } else {
                        createExplosion(roadRightEdge, playerCarY + playerCarHeight / 2);
                    }
                    
                    if (playerLife <= 0) {
                        stopGame(lang.crashedWalls);
                        return;
                    }
                }
                playerCarX = Math.max(roadLeftEdge, Math.min(playerCarX, roadRightEdge - playerCarWidth));
            }
        }

        function checkLaps() {
            if (!gameRunning) return;
            const prevFinishLineY = finishLineY;
            finishLineY += playerCurrentSpeed * deltaTime;

            if (
                prevFinishLineY < playerCarY + playerCarHeight &&
                finishLineY >= playerCarY + playerCarHeight
            ) {
                if (!finishLinePassed) {
                    playerLap++;
                    finishLinePassed = true;
                }
            } else if (finishLineY >= BASE_HEIGHT + 100) {
                finishLineY = -100 - Math.random() * 200;
                finishLinePassed = false;
            }

            if (playerLap >= lapTarget) {
                stopGame(lang.win);
                return;
            }
        }

        function drawEverything() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scale, scale);

            // Draw grass and road
            drawRect(0, 0, BASE_WIDTH, BASE_HEIGHT, 'darkgreen');
            const roadX = (BASE_WIDTH - roadWidth) / 2;
            drawRect(roadX, 0, roadWidth, BASE_HEIGHT, '#333');

            // Draw road lines
            roadOffset = (roadOffset + playerCurrentSpeed * deltaTime) % 100;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 5;
            const numLines = Math.ceil(BASE_HEIGHT / 50);
            for (let i = 0; i < numLines; i++) {
                const lineY = (i * 100 + roadOffset) % (BASE_HEIGHT + 100) - 100;
                ctx.beginPath();
                ctx.setLineDash([30, 20]);
                ctx.moveTo(BASE_WIDTH / 2, lineY);
                ctx.lineTo(BASE_WIDTH / 2, lineY + 50);
                ctx.stroke();

                ctx.setLineDash([10, 30]);
                for (let j = 1; j < 4; j++) {
                    const laneDividerX = roadX + j * laneWidth;
                    ctx.beginPath();
                    ctx.moveTo(laneDividerX, lineY);
                    ctx.lineTo(laneDividerX, lineY + 50);
                    ctx.stroke();
                }
            }
            ctx.setLineDash([]);

            // Draw finish line
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(roadX, finishLineY);
            ctx.lineTo(roadX + roadWidth, finishLineY);
            ctx.stroke();

            // Draw cars
            drawCar(playerCarX, playerCarY, playerCarWidth, playerCarHeight, 'yellow');
            for (const aiCar of aiCars) {
                drawCar(aiCar.x, aiCar.y, aiCarWidth, aiCarHeight, aiCar.color);
            }
            if (policeCar) {
                drawCarWithLights(policeCar.x, policeCar.y, policeCar.width, policeCar.height, "#3366CC", true);
            }
            
            // Draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.lifetime <= 0) {
                    particles.splice(i, 1);
                }
            }

            // --- DRAW UI ---
            // Lap Counter
            const lapBoxWidth = 160, lapBoxHeight = 35;
            const lapBoxX = BASE_WIDTH / 2 - lapBoxWidth / 2, lapBoxY = 10;
            drawRoundedRect(lapBoxX, lapBoxY, lapBoxWidth, lapBoxHeight, 8, 'rgba(0, 0, 0, 0.6)', 'white', 1);
            drawText(`${lang.lap} ${playerLap}/${lapTarget}`, BASE_WIDTH / 2, lapBoxY + 24, 'white', 20);

            // Life Bar
            const lifeBarWidth = 156, lifeBarHeight = 15;
            const lifeBarX = BASE_WIDTH / 2 - lifeBarWidth / 2, lifeBarY = 60;
            drawRect(lifeBarX, lifeBarY, lifeBarWidth, lifeBarHeight, 'gray');
            const lifeColor = playerLife > 50 ? 'lime' : playerLife > 20 ? 'orange' : 'red';
            drawRect(lifeBarX, lifeBarY, lifeBarWidth * (playerLife / 100), lifeBarHeight, lifeColor);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(lifeBarX, lifeBarY, lifeBarWidth, lifeBarHeight);
            drawText(`${lang.life} ${playerLife}%`, lifeBarX + lifeBarWidth / 2, lifeBarY + lifeBarHeight / 2 + 5, 'black', 12);
            
            // Speed indicator
            drawText(`${lang.speed}: ${Math.round(playerCurrentSpeed)}`, BASE_WIDTH / 2, 95, 'white', 16);

            ctx.restore();
        }

        function resizeCanvas() {
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            const widthRatio = displayWidth / BASE_WIDTH;
            const heightRatio = displayHeight / BASE_HEIGHT;
            scale = Math.min(widthRatio, heightRatio);
            canvas.width = BASE_WIDTH * scale;
            canvas.height = BASE_HEIGHT * scale;
        }

        // --- GAME FLOW & MAIN LOOP ---
        function gameLoop(currentTime) {
            if (!gameRunning) {
                lastTime = currentTime;
                return;
            }
            deltaTime = Math.min(0.05, (currentTime - lastTime) / 1000); // Clamp delta time
            lastTime = currentTime;

            audioManager.updateEngineSound(playerCurrentSpeed, maxSpeed);
            movePlayerCar();
            moveAICars();
            updatePoliceCar();
            updateCarCollisions();
            checkPlayerCollisions();
            checkWallCollisions();
            checkLaps();
            drawEverything();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if (!gameRunning) {
                audioManager.init();
                audioManager.startEngine();
                gameRunning = true;
                gameControlsDiv.style.display = 'none';
                messageBox.style.display = 'none';
                initializeGame();
                lastTime = performance.now();
                drawEverything();
                requestAnimationFrame(gameLoop);
            }
        }

        function stopGame(message) {
            if (gameRunning) {
                gameRunning = false;
                cancelAnimationFrame(animationFrameId);
                audioManager.stopEngine();
                audioManager.stopSiren();
                gameControlsDiv.style.display = 'none';

                const isWin = message.toLowerCase().includes('won');
                messageBox.innerHTML = `
                    <p>${message}</p>
                    <button id="restartButton">${lang.playAgain}</button>
                `;
                messageBox.className = isWin ? 'win' : 'lose';
                messageBox.style.display = 'flex';

                document.getElementById('restartButton').addEventListener('click', startGame);
            }
        }
        
        function updateStaticUIText() {
            document.title = lang.title;
            startGameButton.textContent = lang.startGame;
            document.getElementById('controls-text').textContent = lang.controls;
        }
        
        // --- INITIALIZATION ---
        updateStaticUIText();
        startGameButton.addEventListener('click', startGame);
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!gameRunning) {
                drawEverything(); // Redraw static scene on resize
            }
        });

        // Initial setup
        resizeCanvas();
        initializeGame();
        drawEverything();
    </script>
</body>

</html>
